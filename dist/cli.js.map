{"version":3,"sources":["../src/cli.ts","../src/auth/google.ts","../src/commands/login.ts","../src/git/index.ts","../src/github/api.ts","../src/commands/init.ts","../src/commands/start.ts","../src/commands/config.ts"],"sourcesContent":["import { Command } from 'commander';\nimport { logger } from './utils/logger';\nimport { ExitCode } from './utils/errors';\nimport { runLogin } from './commands/login';\nimport { runInit } from './commands/init';\nimport { runStart } from './commands/start';\nimport { runConfig } from './commands/config';\n\nconst program = new Command();\n\nprogram\n  .name('agent-commits')\n  .description('Reassign AI agent commits to current user with templates')\n  .version('0.1.1');\n\nprogram\n  .command('login')\n  .description('Perform Google SSO and store session locally')\n  .action(async () => {\n    try {\n      await runLogin();\n      process.exit(ExitCode.Success);\n    } catch (e: any) {\n      logger.error(e?.message || String(e));\n      process.exit(e?.code || 1);\n    }\n  });\n\nprogram\n  .command('init')\n  .description('Create agent-* GitHub repository copy using provided token')\n  .requiredOption('-o, --org <org>', 'GitHub organization to create repository under')\n  .option('--private', 'Create private repository', false)\n  .action(async (opts) => {\n    try {\n      await runInit(opts);\n      process.exit(ExitCode.Success);\n    } catch (e: any) {\n      logger.error(e?.message || String(e));\n      process.exit(e?.code || 1);\n    }\n  });\n\nprogram\n  .command('start')\n  .description('Wait for GitHub Actions event and create branch/commit with current user')\n  .requiredOption('-r, --repo <repo>', 'agent-* repository name to listen for events')\n  .requiredOption('-o, --org <org>', 'GitHub organization of agent repo')\n  .option('--poll-interval <seconds>', 'Polling interval for events', '30')\n  .action(async (opts) => {\n    try {\n      await runStart(opts);\n      process.exit(ExitCode.Success);\n    } catch (e: any) {\n      logger.error(e?.message || String(e));\n      process.exit(e?.code || 1);\n    }\n  });\n\nprogram\n  .command('config')\n  .description('Configure branch and commit prefixes')\n  .option('--branch <prefix>', 'Branch name prefix template')\n  .option('--commit <prefix>', 'Commit message prefix template')\n  .action(async (opts) => {\n    try {\n      await runConfig(opts);\n      process.exit(ExitCode.Success);\n    } catch (e: any) {\n      logger.error(e?.message || String(e));\n      process.exit(e?.code || 1);\n    }\n  });\n\nprogram.parseAsync(process.argv);\n\n","import crypto from 'node:crypto';\nimport os from 'node:os';\nimport http from 'node:http';\nimport { exec as execChild } from 'node:child_process';\nimport { logger } from '../utils/logger';\nimport { CliError, ExitCode } from '../utils/errors';\nimport { getState, setState } from '../utils/storage';\n\n// We implement OAuth 2.0 device authorization flow to avoid browser callbacks and native addons.\n// This uses Google's OAuth 2.0 for TV and Limited-Input devices.\n\nconst GOOGLE_DEVICE_URL = 'https://oauth2.googleapis.com/device/code';\nconst GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\nconst GOOGLE_USERINFO = 'https://www.googleapis.com/oauth2/v3/userinfo';\n\n// Scopes: minimal to get user email and profile.\nconst OAUTH_SCOPE = 'openid email profile';\n\nexport interface GoogleClientConfig {\n  clientId: string; // Provided by user via env or config\n  clientSecret?: string; // Optional, required for confidential clients\n}\n\nfunction getClientConfig(): GoogleClientConfig {\n  const clientId = process.env.GOOGLE_OAUTH_CLIENT_ID;\n  const clientSecret = process.env.GOOGLE_OAUTH_CLIENT_SECRET;\n  if (!clientId) {\n    throw new CliError('Google OAuth client id is required in env GOOGLE_OAUTH_CLIENT_ID', ExitCode.GoogleSsoFailed);\n  }\n  return { clientId, clientSecret };\n}\n\nasync function postForm(url: string, params: Record<string, string>): Promise<any> {\n  const body = new URLSearchParams(params).toString();\n  const res = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n  if (!res.ok) {\n    let errBody: any = undefined;\n    try {\n      errBody = await res.json();\n    } catch {}\n    const errCode = errBody?.error;\n    // For device endpoints we may get 400s for pending/slowdown. Let caller decide.\n    if (errCode === 'authorization_pending' || errCode === 'slow_down') {\n      const error = new Error(errCode) as any;\n      (error as any).oauthError = errCode;\n      throw error;\n    }\n    if (errCode === 'invalid_request' && /client_secret/i.test(errBody?.error_description || '')) {\n      throw new CliError(\n        'Google OAuth client secret required. Set GOOGLE_OAUTH_CLIENT_SECRET for confidential clients.',\n        ExitCode.GoogleSsoFailed,\n      );\n    }\n    const text = errBody ? JSON.stringify(errBody) : await res.text();\n    logger.error(`HTTP ${res.status} ${res.statusText}`);\n    throw new CliError(`Request failed: ${res.status} ${text}`, ExitCode.NetworkError);\n  }\n  return res.json();\n}\n\nexport async function ensureGoogleLogin(nonInteractive = true): Promise<void> {\n  const state = getState();\n  const now = Date.now();\n  if (state.google && state.google.expiresAt - 60_000 > now) {\n    logger.debug('Google session is valid');\n    return;\n  }\n  // No refresh token in device flow by default (unless configured). We perform device login again.\n  await deviceLogin(nonInteractive);\n}\n\nexport async function deviceLogin(nonInteractive = true): Promise<void> {\n  const { clientId } = getClientConfig();\n  logger.info('Starting Google SSO (device flow)');\n  const init = await postForm(GOOGLE_DEVICE_URL, {\n    client_id: clientId,\n    scope: OAUTH_SCOPE,\n  });\n\n  const verificationUrl = init.verification_url || init.verification_uri;\n  const userCode = init.user_code;\n  const deviceCode = init.device_code;\n  let pollInterval = (init.interval || 5) * 1000;\n  const expiresIn = init.expires_in * 1000;\n\n  logger.info(`Open URL to authorize: ${verificationUrl}`);\n  logger.info(`User code: ${userCode}`);\n\n  // Attempt to open default browser non-blocking; ignore failures\n  try {\n    const cmd = process.platform === 'win32' ? 'start' : process.platform === 'darwin' ? 'open' : 'xdg-open';\n    execChild(`${cmd} ${verificationUrl}`);\n  } catch {}\n\n  const startTime = Date.now();\n  while (Date.now() - startTime < expiresIn) {\n    await new Promise((r) => setTimeout(r, pollInterval));\n    try {\n      const { clientSecret } = getClientConfig();\n      const body = new URLSearchParams({\n        client_id: clientId,\n        device_code: deviceCode,\n        grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n        ...(clientSecret ? { client_secret: clientSecret } : {}),\n      }).toString();\n      const res = await fetch(GOOGLE_TOKEN_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        body,\n      });\n\n      if (res.ok) {\n        const token = await res.json();\n        if (token.access_token) {\n          const profileRes = await fetch(GOOGLE_USERINFO, {\n            headers: { Authorization: `Bearer ${token.access_token}` },\n          });\n          const profile = await profileRes.json();\n          const state = getState();\n          state.google = {\n            accessToken: token.access_token,\n            refreshToken: token.refresh_token,\n            expiresAt: Date.now() + token.expires_in * 1000,\n            email: profile.email,\n            sub: profile.sub,\n          };\n          setState(state);\n          logger.info('Google SSO success');\n          return;\n        }\n      } else {\n        let errBody: any = undefined;\n        try {\n          errBody = await res.json();\n        } catch {}\n        const errCode = errBody?.error;\n        if (errCode === 'authorization_pending') {\n          // Continue polling\n          continue;\n        }\n        if (errCode === 'slow_down') {\n          // Increase polling interval by 5 seconds as per spec\n          pollInterval += 5_000;\n          continue;\n        }\n        if (errCode === 'access_denied') {\n          throw new CliError('Google SSO was denied by user', ExitCode.GoogleSsoFailed);\n        }\n        if (errCode === 'expired_token' || errCode === 'invalid_grant') {\n          throw new CliError('Google SSO device code expired or invalid', ExitCode.GoogleSsoFailed);\n        }\n        if (errCode === 'invalid_request' && /client_secret/i.test(errBody?.error_description || '')) {\n          throw new CliError(\n            'Google OAuth client secret required. Set GOOGLE_OAUTH_CLIENT_SECRET for confidential clients.',\n            ExitCode.GoogleSsoFailed,\n          );\n        }\n\n        const text = errBody ? JSON.stringify(errBody) : await res.text();\n        logger.error(`HTTP ${res.status} ${res.statusText}`);\n        throw new CliError(`Request failed: ${res.status} ${text}`, ExitCode.NetworkError);\n      }\n    } catch (e: any) {\n      // Network errors should bubble up; others are handled above\n      if (e?.code === ExitCode.NetworkError || e?.code === ExitCode.GoogleSsoFailed) throw e;\n    }\n  }\n  throw new CliError('Google SSO timed out', ExitCode.GoogleSsoFailed);\n}\n\nexport function requireGoogle(): void {\n  const st = getState();\n  if (!st.google || st.google.expiresAt <= Date.now()) {\n    throw new CliError(\n      'Google SSO required. Run: agent-commits login',\n      ExitCode.NotLoggedIn,\n    );\n  }\n}\n\nexport function getGoogleAccessToken(): string {\n  const st = getState();\n  if (!st.google || st.google.expiresAt <= Date.now()) {\n    throw new CliError('Google session expired', ExitCode.SessionExpired);\n  }\n  return st.google.accessToken;\n}\n\n","import { ensureGoogleLogin } from '../auth/google';\nimport { logger } from '../utils/logger';\n\nexport async function runLogin(): Promise<void> {\n  await ensureGoogleLogin(true);\n  logger.info('Logged in with Google SSO.');\n}\n\n","import { execSync } from 'node:child_process';\nimport { logger } from '../utils/logger';\nimport { CliError, ExitCode } from '../utils/errors';\n\nfunction run(command: string, options: { cwd?: string; env?: NodeJS.ProcessEnv; sensitive?: boolean } = {}): string {\n  try {\n    if (!options.sensitive) {\n      logger.debug(`$ ${command}`);\n    }\n    const out = execSync(command, {\n      stdio: ['ignore', 'pipe', 'pipe'],\n      encoding: 'utf8',\n      cwd: options.cwd,\n      env: { ...process.env, ...(options.env || {}) },\n    });\n    return out.trim();\n  } catch (e: any) {\n    throw new CliError(`Git command failed: ${command}\\n${e?.stderr || e?.message || ''}`, ExitCode.GitFailed);\n  }\n}\n\nexport function ensureRepo(): void {\n  try {\n    run('git rev-parse --is-inside-work-tree');\n  } catch (e) {\n    throw new CliError('Not a git repository', ExitCode.NotAGitRepo);\n  }\n}\n\nexport function getRepoRoot(): string {\n  return run('git rev-parse --show-toplevel');\n}\n\nexport function getRepoAuthor(): string {\n  return run('git config user.name');\n}\n\nexport function getRepoName(): string {\n  const root = getRepoRoot();\n  return root.split(/[/\\\\]/).pop() as string;\n}\n\nexport function getRemoteUrl(remote = 'origin'): string | null {\n  try {\n    return run(`git remote get-url ${remote}`);\n  } catch {\n    return null;\n  }\n}\n\nexport function createBranch(name: string): void {\n  run(`git checkout -b ${name}`);\n}\n\nexport function switchBranch(name: string): void {\n  run(`git checkout ${name}`);\n}\n\nexport function currentBranch(): string {\n  return run('git rev-parse --abbrev-ref HEAD');\n}\n\nexport function commitAll(message: string, authorName?: string, authorEmail?: string): void {\n  run('git add -A');\n  const env: NodeJS.ProcessEnv = {};\n  if (authorName) {\n    env.GIT_AUTHOR_NAME = authorName;\n    env.GIT_COMMITTER_NAME = authorName;\n  }\n  if (authorEmail) {\n    env.GIT_AUTHOR_EMAIL = authorEmail;\n    env.GIT_COMMITTER_EMAIL = authorEmail;\n  }\n  run(`git commit --allow-empty -m \"${message.replace(/\"/g, '\\\\\"')}\"`, { env });\n}\n\nexport function setRemote(name: string, url: string): void {\n  const existing = getRemoteUrl(name);\n  if (existing) {\n    run(`git remote set-url ${name} ${url}`);\n  } else {\n    run(`git remote add ${name} ${url}`);\n  }\n}\n\nexport function push(remote = 'origin', branch?: string): void {\n  const b = branch || currentBranch();\n  run(`git push -u ${remote} ${b}`);\n}\n\nexport function getUserEmail(): string {\n  try {\n    return run('git config user.email');\n  } catch {\n    return '';\n  }\n}\n\nexport function getUserName(): string {\n  try {\n    return run('git config user.name');\n  } catch {\n    return '';\n  }\n}\n\nexport function pushAllToUrlWithToken(url: string, token: string): void {\n  const basic = Buffer.from(`x-access-token:${token}`, 'utf8').toString('base64');\n  const env = { GIT_HTTP_EXTRAHEADER: `Authorization: Basic ${basic}` } as NodeJS.ProcessEnv;\n  run(`git push --all ${url}`, { env, sensitive: true });\n  run(`git push --tags ${url}`, { env, sensitive: true });\n}\n\n","import { logger } from '../utils/logger';\nimport { CliError, ExitCode } from '../utils/errors';\nimport { getState, setState } from '../utils/storage';\n\nexport interface GithubContext {\n  token: string;\n  username: string;\n  org?: string; // optional org to create repos under\n}\n\nfunction getToken(): string {\n  const env = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n  const st = getState();\n  const token = env || st.github.token;\n  if (!token) throw new CliError('GitHub token is required. Set GITHUB_TOKEN or run config.', ExitCode.MissingGithubToken);\n  return token;\n}\n\nexport async function getAuthenticatedUser(): Promise<string> {\n  const token = getToken();\n  const res = await fetch('https://api.github.com/user', {\n    headers: {\n      Authorization: `token ${token}`,\n      'User-Agent': 'agent-commits-cli',\n      Accept: 'application/vnd.github+json',\n    },\n  });\n  if (!res.ok) {\n    throw new CliError('GitHub API auth failed', res.status === 401 ? ExitCode.Unauthorized : ExitCode.GithubApiError);\n  }\n  const user = await res.json();\n  const username = user.login as string;\n  const state = getState();\n  state.github.username = username;\n  state.github.token = token; // stored locally\n  setState(state);\n  return username;\n}\n\nexport interface CreateRepoParams {\n  org: string;\n  name: string;\n  description?: string;\n  private?: boolean;\n}\n\nexport async function createRepository({ org, name, description, private: isPrivate = false }: CreateRepoParams): Promise<string> {\n  const token = getToken();\n  const res = await fetch(`https://api.github.com/orgs/${org}/repos`, {\n    method: 'POST',\n    headers: {\n      Authorization: `token ${token}`,\n      'User-Agent': 'agent-commits-cli',\n      Accept: 'application/vnd.github+json',\n    },\n    body: JSON.stringify({ name, description, private: isPrivate, has_issues: true, has_wiki: false }),\n  });\n  if (!res.ok) {\n    const text = await res.text();\n    logger.error('Failed to create repo', { status: res.status, text });\n    throw new CliError('GitHub create repo failed', ExitCode.GithubApiError);\n  }\n  const repo = await res.json();\n  return repo.clone_url as string;\n}\n\nexport async function createRepoFromTemplate({ org, name, templateOwner, templateRepo }: { org: string; name: string; templateOwner: string; templateRepo: string; }): Promise<string> {\n  const token = getToken();\n  const res = await fetch(`https://api.github.com/repos/${templateOwner}/${templateRepo}/generate`, {\n    method: 'POST',\n    headers: {\n      Authorization: `token ${token}`,\n      'User-Agent': 'agent-commits-cli',\n      Accept: 'application/vnd.github+json',\n    },\n    body: JSON.stringify({ owner: org, name, include_all_branches: false, private: false }),\n  });\n  if (!res.ok) {\n    const text = await res.text();\n    logger.error('Failed to generate repo from template', { status: res.status, text });\n    throw new CliError('GitHub template generate failed', ExitCode.GithubApiError);\n  }\n  const repo = await res.json();\n  return repo.clone_url as string;\n}\n\n","import { requireGoogle } from '../auth/google';\nimport { logger } from '../utils/logger';\nimport { ensureRepo, getRepoAuthor, getRepoName, getRemoteUrl, pushAllToUrlWithToken } from '../git';\nimport { getAuthenticatedUser, createRepository } from '../github/api';\nimport { CliError, ExitCode } from '../utils/errors';\n\nexport interface InitOptions {\n  org: string;\n  private?: boolean;\n}\n\nexport async function runInit(options: InitOptions): Promise<void> {\n  requireGoogle();\n  ensureRepo();\n\n  const org = options.org;\n  if (!org) throw new CliError('Missing --org', ExitCode.InvalidArgs);\n\n  const author = getRepoAuthor();\n  const repoName = getRepoName();\n  const agentRepo = `agent-${author}-${repoName}`.replace(/[^A-Za-z0-9-_]/g, '-');\n  logger.info(`Will create repository: ${org}/${agentRepo}`);\n\n  const ghUser = await getAuthenticatedUser();\n  logger.info(`Authenticated as GitHub user: ${ghUser}`);\n\n  const cloneUrl = await createRepository({ org, name: agentRepo, description: `Agent mirror for ${repoName} by ${author}`, private: !!options.private });\n  logger.info('Created repository', { cloneUrl });\n\n  const upstream = getRemoteUrl('origin');\n  if (!upstream) {\n    logger.warn('No origin remote found. Skipping push to agent repo.');\n    return;\n  }\n  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n  if (!token) throw new CliError('GITHUB_TOKEN required to push', ExitCode.MissingGithubToken);\n  logger.info('Pushing all branches and tags to agent repository...');\n  // Convert clone URL to https with token-less URL, we use header-based auth\n  const pushUrl = cloneUrl;\n  pushAllToUrlWithToken(pushUrl, token);\n  logger.info('Push completed');\n}\n\n","import { requireGoogle } from '../auth/google';\nimport { logger } from '../utils/logger';\nimport { createBranch, commitAll, currentBranch, ensureRepo, getUserEmail, switchBranch } from '../git';\nimport { getConfig } from '../utils/storage';\nimport { CliError, ExitCode } from '../utils/errors';\n\nexport interface StartOptions {\n  org: string;\n  repo: string; // agent-* repo name\n  pollInterval?: string; // seconds\n}\n\nasync function pollWorkflowEvent(org: string, repo: string, token: string, intervalMs: number): Promise<any> {\n  const url = `https://api.github.com/repos/${org}/${repo}/actions/runs?per_page=1`;\n  while (true) {\n    const res = await fetch(url, { headers: { Authorization: `token ${token}`, 'User-Agent': 'agent-commits-cli' } });\n    if (!res.ok) throw new CliError('GitHub API error while polling', ExitCode.GithubApiError);\n    const data = await res.json();\n    if (data.workflow_runs && data.workflow_runs.length) {\n      const run = data.workflow_runs[0];\n      // Deterministic trigger: completed and with conclusion success\n      if (run.status === 'completed') return run;\n    }\n    logger.info('No completed runs yet; waiting...');\n    await new Promise((r) => setTimeout(r, intervalMs));\n  }\n}\n\nexport async function runStart(options: StartOptions): Promise<void> {\n  requireGoogle();\n  ensureRepo();\n  const cfg = getConfig('project');\n  const pollIntervalSec = parseInt(options.pollInterval || '30', 10);\n  if (!Number.isFinite(pollIntervalSec) || pollIntervalSec <= 0) {\n    throw new CliError('Invalid --poll-interval', ExitCode.InvalidArgs);\n  }\n  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n  if (!token) throw new CliError('GITHUB_TOKEN required for polling', ExitCode.MissingGithubToken);\n\n  logger.info(`Polling GitHub Actions for ${options.org}/${options.repo} every ${pollIntervalSec}s`);\n  const event = await pollWorkflowEvent(options.org, options.repo, token, pollIntervalSec * 1000);\n  logger.info('Received event', { id: event.id, status: event.status, conclusion: event.conclusion });\n\n  const branchName = `${cfg.branchPrefix}/${String(event.id)}`;\n  const commitMessage = `${cfg.commitPrefix}: sync from agent event ${event.id}`;\n\n  const prevBranch = currentBranch();\n  try {\n    createBranch(branchName);\n  } catch (e) {\n    // If branch exists, switch to it\n    switchBranch(branchName);\n  }\n\n  const authorEmail = getUserEmail();\n  // Use git configured user for deterministic authorship\n  const gitUserName = process.env.GIT_AUTHOR_NAME || process.env.GIT_COMMITTER_NAME || process.env.USER || process.env.USERNAME || 'user';\n  commitAll(commitMessage, gitUserName, authorEmail);\n\n  logger.info('Switched to branch and created commit', { branchName, commitMessage });\n}\n\n","import { logger } from '../utils/logger';\nimport { requireGoogle } from '../auth/google';\nimport { setConfig, getConfig } from '../utils/storage';\n\nexport interface ConfigOptions {\n  branch?: string;\n  commit?: string;\n}\n\nexport async function runConfig(options: ConfigOptions): Promise<void> {\n  // Enforce SSO before any command per requirements\n  requireGoogle();\n  const updates: any = {};\n  if (options.branch) updates.branchPrefix = options.branch;\n  if (options.commit) updates.commitPrefix = options.commit;\n  if (Object.keys(updates).length === 0) {\n    const cfg = getConfig('project');\n    logger.info('Current config', cfg);\n    return;\n  }\n  setConfig('project', updates);\n  const after = getConfig('project');\n  logger.info('Updated config', after);\n}\n\n"],"mappings":"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","names":["run"]}